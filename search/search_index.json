{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>msl-nlf</code> is a Python wrapper for the non-linear fitting software that was written by Peter Saunders at the Measurement Standards Laboratory (MSL) of New Zealand. The original source code is written in Delphi and compiled to a shared library to be accessed by other programming languages. The Delphi software also provides a GUI (for Windows only) to visualize and interact with the data. Please contact MSL if you are interested in using the GUI version.</p> <p>The application of non-linear fitting is a general-purpose, curving-fitting program that will fit any curve of the form</p> \\[ y = f(x_1, x_2, ..., x_n, a_1, a_2, ..., a_N) \\] <p>to a set of data, where \\(x_1, x_2, ..., x_n\\), are real variables, which may or may not be correlated, and \\(a_1, a_2, ..., a_N\\) are real parameters. In the Delphi algorithm, \\(n\\) can be any value from 1 to 30 and \\(N\\) from 1 to 99. The function \\(f\\) will be fitted to a set of \\(M\\) data points, \\((x_{1,1}, x_{2,1}, ..., x_{n,1}, y_1), (x_{1,2}, x_{2,2}, ..., x_{n,2}, y_2), ..., (x_{1,M}, x_{2,M}, ..., x_{n,M}, y_M)\\), where \\(M \\geq N\\). The parameters \\(a_1, a_2, ..., a_N\\) can be chosen to be either constant or fitted, providing additional flexibility to the fitting process. If there are constant parameters, then \\(M\\) must be greater than or equal to the number of non-constant parameters.</p> <p>For more details see Propagation of uncertainty for non-linear calibration equations with an application in radiation thermometry, Peter Saunders, Metrologia 40 93 (2003).</p> <p>The non-linear fitting algorithm implements the following features:</p> <ul> <li>perform an unweighted fit or a weighted fit with uncertainties in the \\(x\\) and/or \\(y\\) data</li> <li>setting correlations between the \\(x_i-x_i\\), \\(x_i-x_j\\), \\(x_i-y\\) and/or \\(y-y\\) data</li> <li>whether second-derivative terms (Hessian) are included in the calculation</li> <li>use up to 30 independent variables and up to 99 parameters in the fit equation</li> <li>whether a parameter is held constant or allowed to vary during the fitting process</li> <li>choice of different fitting methods (see the FitMethod enum)</li> </ul> <p>Follow the Install instructions and read the Getting Started guide to begin.</p>"},{"location":"compiled_functions/","title":"Compiled (User-defined) Function","text":""},{"location":"compiled_functions/#overview","title":"Overview","text":"<p>For situations when the fit equation cannot be expressed in analytical form by using the arithmetic operations and functions that are supported, a user-defined function that is compiled as a shared library may be used. This compiled function must export four functions with the following names:</p> <ul> <li>GetFunctionName</li> <li>GetFunctionValue</li> <li>GetNumParameters</li> <li>GetNumVariables</li> </ul>"},{"location":"compiled_functions/#examples","title":"Examples","text":"<p>How to define these four functions is best shown with examples.</p>"},{"location":"compiled_functions/#c-1d-data","title":"C++ (1D data)","text":"<p>A compiled function is created in C++ in order to fit the Roszman1 dataset that is provided by NIST. This fit equation requires the arctan function, which is not one of the built-in functions that are currently supported by the Delphi software (but could be).</p> <p>The header file is</p> <pre><code>// Roszman1.h\n\n#if defined(_MSC_VER)  // Microsoft\n    #define EXPORT __declspec(dllexport)\n#elif defined(__GNUC__)  // GCC\n    #define EXPORT __attribute__((visibility(\"default\")))\n#endif\n\n#define pi 3.141592653589793238462643383279\n\nextern \"C\" {\n    EXPORT void GetFunctionName(char* name);\n    EXPORT void GetFunctionValue(double* x, double* a, double* y);\n    EXPORT void GetNumParameters(int* n);\n    EXPORT void GetNumVariables(int* n);\n}\n</code></pre> <p>and the source file is</p> <pre><code>/*\n* Roszman1.cpp\n*\n* User-defined function for the Roszman1 dataset that is provided by NIST.\n*\n* https://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Roszman1.dat\n*/\n#include &lt;math.h&gt;  // atan\n#include &lt;string.h&gt;  // strcpy\n#include \"Roszman1.h\"\n\nvoid GetFunctionName(char* name) {\n  // The function name must\n  //   - begin with the letter \"f\",\n  //   - followed by a positive integer that uniquely identifies this function,\n  //   - followed by a colon.\n  // The remainder of the string is optional (to describe the function).\n  // The total length of the function name must be &lt; 256 characters.\n  strcpy(name, \"f1: Roszman1 f1=a1-a2*x-arctan(a3/(x-a4))/pi\");\n}\n\nvoid GetFunctionValue(double* x, double* a, double* y) {\n  // Receives the x value, the fit parameters and a pointer to the y value.\n  // C++ array indices are zero based (i.e., a1=a[0] and x=x[0])\n  *y = a[0] - a[1] * x[0] - atan(a[2] / (x[0] - a[3])) / pi;\n}\n\nvoid GetNumParameters(int* n) {\n  // There are 4 parameters: a1, a2, a3, a4\n  *n = 4;\n}\n\nvoid GetNumVariables(int* n) {\n  // There is only 1 independent variable: x\n  *n = 1;\n}\n</code></pre> <p>To compile the C++ source code to a shared library, one could use Visual Studio C++</p> <pre><code>cl /LD Roszman1.cpp\n</code></pre> <p>or gcc</p> <pre><code>gcc -shared Roszman1.cpp\n</code></pre>"},{"location":"compiled_functions/#c-2d-data","title":"C++ (2D data)","text":"<p>A compiled function is created in C++ in order to fit the Nelson dataset that is provided by NIST. This fit equation, <code>a1-a2*x1*exp(-a3*x2)</code>, could have been passed directly to a Model since all arithmetic operations and functions are supported; however, this example illustrates how to define a function if multiple \\(x\\) variables are required.</p> <p>The header file is</p> <pre><code>// Nelson.h\n\n#if defined(_MSC_VER)  // Microsoft\n    #define EXPORT __declspec(dllexport)\n#elif defined(__GNUC__)  // GCC\n    #define EXPORT __attribute__((visibility(\"default\")))\n#endif\n\nextern \"C\" {\n    EXPORT void GetFunctionName(char* name);\n    EXPORT void GetFunctionValue(double* x, double* a, double* y);\n    EXPORT void GetNumParameters(int* n);\n    EXPORT void GetNumVariables(int* n);\n}\n</code></pre> <p>and the source file is</p> <pre><code>/*\n* Nelson.cpp\n*\n* User-defined function for the Nelson dataset that is provided by NIST.\n*\n* https://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Nelson.dat\n*/\n#include &lt;math.h&gt;  // exp\n#include &lt;string.h&gt;  // strcpy\n#include \"Nelson.h\"\n\nvoid GetFunctionName(char* name) {\n  // The function name must\n  //   - begin with the letter \"f\",\n  //   - followed by a positive integer that uniquely identifies this function,\n  //   - followed by a colon.\n  // The remainder of the string is optional (to describe the function).\n  // The total length of the function name must be &lt; 256 characters.\n  strcpy(name, \"f2: Nelson log(f2)=a1-a2*x1*exp(-a3*x2)\");\n}\n\nvoid GetFunctionValue(double* x, double* a, double* y) {\n  // Receives the x value, the fit parameters and a pointer to the y value.\n  // C++ array indices are zero based\n  //  - independent variables: x1=x[0], x2=x[1]\n  //  - parameters: a1=a[0], a2=a[1], a3=a[2]\n  *y = a[0] - a[1] * x[0] * exp(-a[2] * x[1]);\n}\n\nvoid GetNumParameters(int* n) {\n  // There are 3 parameters: a1, a2, a3\n  *n = 3;\n}\n\nvoid GetNumVariables(int* n) {\n  // There are 2 independent variables: x1, x2\n  *n = 2;\n}\n</code></pre> <p>To compile the C++ source code to a shared library, one could use Visual Studio C++</p> <pre><code>cl /LD Nelson.cpp\n</code></pre> <p>or gcc</p> <pre><code>gcc -shared Nelson.cpp\n</code></pre>"},{"location":"compiled_functions/#delphi","title":"Delphi","text":"<p>A compiled function is created in Delphi Pascal for the Beta Distribution.</p> <pre><code>library BetaFCN;\n\nuses\n    SysUtils,\n    Classes,\n    sfGamma in '..\\..\\Maths Functions\\sfgamma.pas',\n    AMath in '..\\..\\Maths Functions\\amath.pas',\n    sfBasic in '..\\..\\Maths Functions\\sfbasic.pas',\n    sfZeta in '..\\..\\Maths Functions\\sfzeta.pas',\n    sfExpInt in '..\\..\\Maths Functions\\sfexpint.pas',\n    sfHyperG in '..\\..\\Maths Functions\\sfhyperg.pas',\n    sfPoly in '..\\..\\Maths Functions\\sfpoly.pas',\n    sfEllInt in '..\\..\\Maths Functions\\sfellint.pas',\n    sfMisc in '..\\..\\Maths Functions\\sfmisc.pas',\n    sfBessel in '..\\..\\Maths Functions\\sfbessel.pas',\n    sfErf in '..\\..\\Maths Functions\\sferf.pas';\n\ntype\n    PArray=^TArray;\n    TArray=array[1..100] of Double;\n\nfunction Gamma(X:Double):Double;\nbegin\n    Gamma:=sfc_gamma(X);\nend;\n\nprocedure GetFunctionName(var Name:PAnsiChar); cdecl;\nbegin\n    {The function name must\n       - begin with the letter \"f\",\n       - followed by a positive integer that uniquely identifies this function,\n       - followed by a colon.\n     The remainder of the string is optional (to describe the function).\n     The total length of the function name must be &lt; 256 characters.}\n    StrCopy(Name, 'f3: Beta Distribution (f3=a3/(a5-a4)*Gamma(a1+a2)/(Gamma(a1)*Gamma(a2))*((x-a4)/(a5-a4))^(a1-1)*((a5-x)/(a5-a4))^(a2-1))');\nend;\n\nprocedure GetFunctionValue(x,a:PArray; var y:Double); cdecl;\n{Returns the value of the user-defined function in the y-variable based on the\ninput x array and a array, where a is the parameter array.}\nvar\n    p1,p2,g1,g2:Double;\nbegin\n    if (a[5]&lt;=a[4]) or (x[1]&lt;=a[4]) or (x[1]&gt;=a[5]) then\n        y:=0\n    else\n    begin\n        p1:=Power((x[1]-a[4])/(a[5]-a[4]),a[1]-1);\n        p2:=Power((a[5]-x[1])/(a[5]-a[4]),a[2]-1);\n        g1:=Gamma(a[1]);\n        g2:=Gamma(a[2]);\n        if (g1=0) or (g1=PosInf_x) or (g2=0) or (g2=PosInf_x) then\n            y:=0\n        else\n            y:=a[3]/(a[5]-a[4])*Gamma(a[1]+a[2])/(g1*g2)*p1*p2;\n    end;\nend;\n\nprocedure GetNumParameters(var NumParameters:Integer); cdecl;\nbegin\n    {There are 5 parameters: a1, a2, a3, a4, a5}\n    NumParameters:=5;\nend;\n\nprocedure GetNumVariables(var NumVariables:Integer); cdecl;\nbegin\n    {There is only 1 independent variable: x}\n    NumVariables:=1;\nend;\n\nexports\n    GetFunctionName index 1,\n    GetFunctionValue index 2,\n    GetNumParameters index 3,\n    GetNumVariables index 4;\n\nbegin\nend.\n</code></pre>"},{"location":"compiled_functions/#using-the-compiled-function","title":"Using the Compiled Function","text":"<p>To use a compiled function, the <code>equation</code> parameter when defining a Model must be the first part of the function name (up to, but excluding, the colon) defined in GetFunctionName, and, optionally, specify the directory where the function is located as a <code>user_dir</code> keyword argument. If you are also using the Delphi GUI, the directory that has been set in the GUI for the user-defined functions will be used as the default <code>user_dir</code> value. Otherwise, the current working directory is used as the default <code>user_dir</code> value if a directory is not explicitly specified.</p> <p>Below, the C++ function <code>f1</code> (from the example) is used for the Model</p> <pre><code>from msl.nlf import Model\n\nmodel = Model(\"f1\", user_dir=\"./tests/user_defined\")\n</code></pre>"},{"location":"compiled_functions/#32-bit-compiled-function","title":"32-bit Compiled Function","text":"<p>A 32-bit version of the Delphi shared library may be loaded in 64-bit Python (Windows only). The primary reason for using the 32-bit shared library on Windows (by setting <code>win32=True</code> when creating a Model) is if you have user-defined functions that were compiled to a 32-bit DLL for use with the 32-bit Delphi GUI application and you do not have a 64-bit version of the DLL. The following table illustrates the differences between using a compiled function as a 32-bit DLL and a 64-bit DLL.</p> 32-bit DLL 64-bit DLL Can be used in both 32- and 64-bit versions of Python Can only be used in 64-bit Python When used in 64-bit Python, the fit will take longer <sup>1</sup> There is no performance overhead Limited to 4GB RAM Can access more than 4GB RAM <p>If loading the 32-bit DLL in 64-bit Python, it is important to reduce the number of times a Model is created to fit data. In this case, creating a Model object takes about 1 second for a client-server protocol to be initialized in the background. Once the Model has been created, the client and server are running and repeatedly calling the fit method will be more efficient (but still slower than fitting data with the 64-bit DLL in 64-bit Python, or the 32-bit DLL in 32-bit Python).</p> <p>Pseudocode is shown below that demonstrates the recommended way to apply fits if loading the 32-bit DLL in 64-bit Python. See A Model as a Context Manager for more details about the use of the with statement</p> <pre><code># Don't do this. Don't create a new model to process each data file.\nfor data in data_files:\n    with LinearModel(win32=True) as model:\n        result = model.fit(data.x, data.y)\n\n# Do this instead. Create a model once and then fit each data file.\nwith LinearModel(win32=True) as model:\n    for data in data_files:\n        result = model.fit(data.x, data.y)\n</code></pre> <ol> <li> <p>This is not due to the 32-bit Delphi code, but due to an overhead on the Python side to exchange data between 64-bit Python and a 32-bit DLL. When the 32-bit DLL is used in 32-bit Python, there is no overhead.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/","title":"Getting Started","text":"<p>As a simple example, one might need to model data that has a linear relationship</p> <pre><code>&gt;&gt;&gt; x = [1.6, 3.2, 5.5, 7.8, 9.4]\n&gt;&gt;&gt; y = [7.8, 19.1, 17.6, 33.9, 45.4]\n</code></pre> <p>The first task to perform is to create a Model and specify the fit equation as a string (see the documentation of Model for an overview of what arithmetic operations and functions are allowed in the equation)</p> <pre><code>&gt;&gt;&gt; from msl.nlf import Model\n&gt;&gt;&gt; model = Model(\"a1+a2*x\")\n</code></pre> <p>Provide an initial guess for the parameters (<code>a1</code>, <code>a2</code>) and apply the fit</p> <pre><code>&gt;&gt;&gt; result = model.fit(x, y, params=[1, 1])\n&gt;&gt;&gt; result.params\nResultParameters(\n    ResultParameter(name='a1', value=0.522439024..., uncert=5.132418149..., label=None),\n    ResultParameter(name='a2', value=4.406829268..., uncert=0.827701724..., label=None)\n)\n</code></pre> <p>The Result object that is returned from the fit contains information about the fit result, such as the chi-square value and the covariance matrix, but we simply showed a summary of the fit parameters above.</p>"},{"location":"getting_started/#input-parameters","title":"Input Parameters","text":"<p>If you want to have control over which parameters should be held constant during the fitting process and which are allowed to vary or if you want to assign a label to a parameter, you need to create an InputParameters instance.</p> <p>In this case, we will use one of the built-in models (a LinearModel) to perform the linear fit and create InputParameters. We use the InputParameters instance to provide an initial value for each parameter, define labels, and set whether the initial value of a parameter is held constant during the fitting process</p> <pre><code>&gt;&gt;&gt; from msl.nlf import LinearModel\n&gt;&gt;&gt; model = LinearModel()\n&gt;&gt;&gt; model.equation\n'a1+a2*x'\n&gt;&gt;&gt; params = model.create_parameters()\n&gt;&gt;&gt; a1 = params.add(name=\"a1\", value=0, constant=True, label=\"intercept\")\n&gt;&gt;&gt; params[\"a2\"] = 1, False, \"slope\"  # alternative way to add a parameter\n&gt;&gt;&gt; result = model.fit(x, y, params=params)\n&gt;&gt;&gt; result.params\nResultParameters(\n    ResultParameter(name='a1', value=0.0, uncert=0.0, label='intercept'),\n    ResultParameter(name='a2', value=4.4815604681..., uncert=0.3315980376..., label='slope')\n)\n</code></pre> <p>We showed above that calling create_parameters is one way to create an InputParameters instance. It can also be instantiated directly</p> <pre><code>&gt;&gt;&gt; from msl.nlf import InputParameters\n&gt;&gt;&gt; params = InputParameters()\n</code></pre> <p>There are multiple ways to add a parameter to an InputParameters object. To add a parameter, you could explicitly add an instance of an InputParameters using the add method (or as one would add items to a dict)</p> <pre><code>&gt;&gt;&gt; from msl.nlf import InputParameter\n&gt;&gt;&gt; a1 = params.add(InputParameter(\"a1\", 1))\n&gt;&gt;&gt; a2 = params.add(InputParameter(\"a2\", 2, constant=True))\n&gt;&gt;&gt; a3 = params.add(InputParameter(\"a3\", 3, constant=True, label=\"label-3\"))\n&gt;&gt;&gt; params[\"a4\"] = InputParameter(\"a4\", 4)\n</code></pre> <p>You could also specify multiple positional arguments (or assign several parameters using the mapping syntax)</p> <pre><code>&gt;&gt;&gt; a5 = params.add(\"a5\", 5)\n&gt;&gt;&gt; a6 = params.add(\"a6\", 6, True)\n&gt;&gt;&gt; a7 = params.add(\"a7\", 7, False, \"label-7\")\n&gt;&gt;&gt; params[\"a8\"] = 8\n&gt;&gt;&gt; params[\"a9\"] = 9, True\n&gt;&gt;&gt; params[\"a10\"] = 10, True, \"label-10\"\n</code></pre> <p>or you could specify keyword arguments (or set it equal to a dict)</p> <pre><code>&gt;&gt;&gt; a11 = params.add(name=\"a11\", value=11)\n&gt;&gt;&gt; a12 = params.add(name=\"a12\", value=12, constant=True)\n&gt;&gt;&gt; a13 = params.add(name=\"a13\", value=13, label=\"label-13\")\n&gt;&gt;&gt; a14 = params.add(name=\"a14\", value=14, constant=False, label=\"label-14\")\n&gt;&gt;&gt; params[\"a15\"] = {\"value\": 15}\n&gt;&gt;&gt; params[\"a16\"] = {\"value\": 16, \"constant\": True}\n&gt;&gt;&gt; params[\"a17\"] = {\"value\": 17, \"label\": \"label-17\"}\n&gt;&gt;&gt; params[\"a18\"] = {\"value\": 18, \"constant\": False, \"label\": \"label-18\"}\n</code></pre> <p>There is an add_many method as well.</p> <p>Here, we iterate through the collection of input parameters to see what it contains</p> <pre><code>&gt;&gt;&gt; for param in params:\n...     print(param)\nInputParameter(name='a1', value=1.0, constant=False, label=None)\nInputParameter(name='a2', value=2.0, constant=True, label=None)\nInputParameter(name='a3', value=3.0, constant=True, label='label-3')\nInputParameter(name='a4', value=4.0, constant=False, label=None)\nInputParameter(name='a5', value=5.0, constant=False, label=None)\nInputParameter(name='a6', value=6.0, constant=True, label=None)\nInputParameter(name='a7', value=7.0, constant=False, label='label-7')\nInputParameter(name='a8', value=8.0, constant=False, label=None)\nInputParameter(name='a9', value=9.0, constant=True, label=None)\nInputParameter(name='a10', value=10.0, constant=True, label='label-10')\nInputParameter(name='a11', value=11.0, constant=False, label=None)\nInputParameter(name='a12', value=12.0, constant=True, label=None)\nInputParameter(name='a13', value=13.0, constant=False, label='label-13')\nInputParameter(name='a14', value=14.0, constant=False, label='label-14')\nInputParameter(name='a15', value=15.0, constant=False, label=None)\nInputParameter(name='a16', value=16.0, constant=True, label=None)\nInputParameter(name='a17', value=17.0, constant=False, label='label-17')\nInputParameter(name='a18', value=18.0, constant=False, label='label-18')\n</code></pre> <p>or just get all of the values</p> <pre><code>&gt;&gt;&gt; params.values()\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.,  10.,  11.,  12.,  13.,\n        14., 15., 16., 17., 18.])\n</code></pre> <p>You can get a specific parameter by its name or label (provided that the label is not None)</p> <pre><code>&gt;&gt;&gt; params[\"a3\"]\nInputParameter(name='a3', value=3.0, constant=True, label='label-3')\n&gt;&gt;&gt; params[\"label-14\"]\nInputParameter(name='a14', value=14.0, constant=False, label='label-14')\n</code></pre> <p>and you can update a parameter by specifying its name or label to the update method</p> <pre><code>&gt;&gt;&gt; params.update(\"a1\", value=5.3, label=\"intercept\")\n&gt;&gt;&gt; params[\"a1\"]\nInputParameter(name='a1', value=5.3, constant=False, label='intercept')\n\n&gt;&gt;&gt; params.update(\"label-7\", value=1e3, constant=True, label=\"amplitude\")\n&gt;&gt;&gt; params[\"a7\"]\nInputParameter(name='a7', value=1000.0, constant=True, label='amplitude')\n</code></pre> <p>or you can update a parameter by directly modifying an attribute</p> <pre><code>&gt;&gt;&gt; a1.label = \"something-new\"\n&gt;&gt;&gt; a1.constant = False\n&gt;&gt;&gt; a1.value = -3.2\n&gt;&gt;&gt; params[\"a1\"]\nInputParameter(name='a1', value=-3.2, constant=False, label='something-new')\n\n&gt;&gt;&gt; params[\"label-3\"].label = \"fwhm\"\n&gt;&gt;&gt; params[\"fwhm\"].constant = True\n&gt;&gt;&gt; params[\"fwhm\"].value = 0.03\n&gt;&gt;&gt; params[\"a3\"]\nInputParameter(name='a3', value=0.03, constant=True, label='fwhm')\n</code></pre>"},{"location":"getting_started/#debugging-input","title":"Debugging (Input)","text":"<p>If you call the fit method with <code>debug=True</code> the fit function in the shared library is not called and an Input object is returned that contains the information that would have been sent to the fit function in the shared library</p> <pre><code>&gt;&gt;&gt; model = LinearModel()\n&gt;&gt;&gt; model_input = model.fit(x, y, params=[1, 1], debug=True)\n&gt;&gt;&gt; model_input.weighted\nFalse\n&gt;&gt;&gt; model_input.fit_method\n&lt;FitMethod.LM: 'Levenberg-Marquardt'&gt;\n&gt;&gt;&gt; model_input.x\narray([[1.6, 3.2, 5.5, 7.8, 9.4]])\n</code></pre> <p>You can display a summary of all input information</p> <pre><code>&gt;&gt;&gt; model_input\nInput(\n    absolute_residuals=True\n    correlated=False\n    correlations=\n    Correlations(\n        data=[]\n        is_correlated=[[False False]\n                       [False False]]\n    )\n    delta=0.1\n    equation='a1+a2*x'\n    fit_method=&lt;FitMethod.LM: 'Levenberg-Marquardt'&gt;\n    max_iterations=999\n    params=\n    InputParameters(\n        InputParameter(name='a1', value=1.0, constant=False, label=None),\n        InputParameter(name='a2', value=1.0, constant=False, label=None)\n    )\n    residual_type=&lt;ResidualType.DY_X: 'dy v x'&gt;\n    second_derivs_B=True\n    second_derivs_H=True\n    tolerance=1e-20\n    ux=[[0. 0. 0. 0. 0.]]\n    uy=[0. 0. 0. 0. 0.]\n    uy_weights_only=False\n    weighted=False\n    x=[[1.6 3.2 5.5 7.8 9.4]]\n    y=[ 7.8 19.1 17.6 33.9 45.4]\n)\n</code></pre>"},{"location":"getting_started/#fit-result","title":"Fit Result","text":"<p>When a fit is performed, the returned object is a Result instance</p> <pre><code>&gt;&gt;&gt; model = LinearModel()\n&gt;&gt;&gt; result = model.fit(x, y, params=[1, 1])\n&gt;&gt;&gt; result.chisq\n84.266087804...\n&gt;&gt;&gt; result.correlation\narray([[ 1.        , -0.88698141],\n        [-0.88698141,  1.        ]])\n&gt;&gt;&gt; result.params.values()\narray([0.52243902, 4.40682927])\n&gt;&gt;&gt; for param in result.params:\n...     print(param.name, param.value, param.uncert)\na1 0.5224390243941... 5.132418149940...\na2 4.4068292682920... 0.827701724508...\n</code></pre> <p>You can display a summary of the fit result</p> <pre><code>&gt;&gt;&gt; result\nResult(\n    chisq=84.266087804878\n    correlation=[[ 1.         -0.88698141]\n                [-0.88698141  1.        ]]\n    covariance=[[ 0.93780488 -0.13414634]\n                [-0.13414634  0.02439024]]\n    dof=3.0\n    eof=5.299876973568286\n    iterations=22\n    num_calls=2\n    params=\n    ResultParameters(\n        ResultParameter(name='a1', value=0.5224390243941934, uncert=5.132418149940028, label=None),\n        ResultParameter(name='a2', value=4.4068292682920465, uncert=0.8277017245089597, label=None)\n    )\n)\n</code></pre> <p>Using the result object and the evaluate method, the residuals can be calculated</p> <pre><code>&gt;&gt;&gt; y - model.evaluate(x, result)\narray([ 0.22663415,  4.47570732, -7.16      , -0.99570732,  3.45336585])\n</code></pre>"},{"location":"getting_started/#save-and-load-nlf-files","title":"Save and Load <code>.nlf</code> Files","text":"<p>A Model can be saved to a file and loaded from a file. The file that is created with <code>msl-nlf</code> can also be opened in the Delphi GUI application and a <code>.nlf</code> file that is created in the Delphi GUI application can be loaded in <code>msl-nlf</code>. See the save method and the load function for more details.</p> <pre><code># Create a model\nfrom msl.nlf import LinearModel\n\nmodel = LinearModel()\nmodel.fit([1, 2, 3], [0.07, 0.27, 0.33])\n\n# Save the model to a file.\n# The results of the fit are not written to the file, so if you are\n# opening \"samples.nlf\" in the Delphi GUI, click the Calculate button\n# and the Results table and the Graphs will be updated.\nmodel.save(\"samples.nlf\")\n\n# At a later date, load the file and perform the fit\nfrom msl.nlf import load\n\nloaded = load(\"samples.nlf\")\nresults = loaded.fit(loaded.x, loaded.y, params=loaded.params)\n</code></pre>"},{"location":"getting_started/#a-model-as-a-context-manager","title":"A Model as a Context Manager","text":"<p>The fit function in the shared library reads the information it needs for the fitting process from RAM but also from files on the hard disk. Configuration (and perhaps correlation) files are written to a temporary directory for the shared library to read from. This temporary directory should automatically get deleted when you are done using the Model (when the objects reference count is 0 and gets garbage collected).</p> <p>Also, if loading a 32-bit version of the shared library in 64-bit Python (see 32-bit Compiled Functions) a client-server application starts in the background when a Model is created. Similarly, the client-server application should automatically shut down when you are done using the Model.</p> <p>A Model can be used as a context manager (see the with statement for more details) which will delete the temporary directory (and shut down the client-server application if one has started) once the with block is finished, for example,</p> <pre><code>from msl.nlf import Model\n\nx = [1, 2, 3, 4, 5]\ny = [1.1, 4.02, 9.2, 16.2, 25.5]\n\nwith Model(\"a1*x^2\") as model:  # temporary directory created\n    result = model.fit(x, y, params=[1])\n\n# no longer in the 'with' block\n# temporary files have been deleted\n# you must create a new Model if you want to use it again\n</code></pre> <p>It is your choice if you want to use a Model as a context manager. There is no difference in performance, but the cleanup steps are more likely to occur when used as a context manager.</p>"},{"location":"install/","title":"Install","text":"<p><code>msl-nlf</code> is available for installation via the Python Package Index and may be installed with pip</p> <pre><code>pip install msl-nlf\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":"<ul> <li>Python 3.8+</li> <li>numpy</li> <li>msl-loadlib (Windows only)</li> </ul>"},{"location":"install/#optional-dependencies","title":"Optional Dependencies","text":"<p>The GUM Tree Calculator, GTC, is not automatically installed when <code>msl-nlf</code> is installed, but it is required to create a correlated ensemble of uncertain real numbers from a Result.</p> <p>To automatically include GTC when installing <code>msl-nlf</code> you may use</p> <pre><code>pip install msl-nlf[gtc]\n</code></pre>"},{"location":"about/developers/","title":"Developers","text":"<ul> <li>Joseph Borbely, joseph.borbely@measurement.govt.nz</li> <li>Peter Saunders, peter.saunders@measurement.govt.nz</li> </ul>"},{"location":"about/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#5460-in-development","title":"5.46.0 (in development)","text":""},{"location":"api/datatypes/","title":"Datatypes","text":"<p>Various data classes and enums.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.Correlation","title":"Correlation  <code>dataclass</code>","text":"<pre><code>Correlation(path, coefficients)\n</code></pre> <p>Information about correlation coefficients.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>The path to the correlation file.</p> <code>coefficients</code> <code>NDArray[float64]</code> <p>The correlation coefficients.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.Correlations","title":"Correlations  <code>dataclass</code>","text":"<pre><code>Correlations(data, is_correlated)\n</code></pre> <p>Information about the correlations for a fit model.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>list[Correlation]</code> <p>A list of Correlation objects.</p> <code>is_correlated</code> <code>NDArray[bool_]</code> <p>Indicates which variables are correlated. The index 0 corresponds to the <code>y</code>-variable, the index 1 to <code>x1</code>, 2 to <code>x2</code>, etc.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.FitMethod","title":"FitMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Fitting methods.</p> <p>Least squares (LS) minimises the sum of the squares of the vertical distances between each point and the fitted curve. The algorithms implemented for Levenberg Marquardt, Amoeba and Powell are described in Numerical Recipes.</p> <p>Minimum distance (MD) minimises the sum of the distances (in two dimensions) between each point and the fitted curve. This type of fit is not available when data is correlated nor is it available when there is more than one independent variable (stimulus).</p> <p>MiniMax (MM) minimises the value of the maximum absolute y-residual. This type of fit is not available when data is correlated.</p> <p>Attributes:</p> Name Type Description <code>LM</code> <code>str</code> <p>Levenberg-Marquardt.</p> <code>AMOEBA_LS</code> <code>str</code> <p>Amoeba least squares.</p> <code>AMOEBA_MD</code> <code>str</code> <p>Amoeba minimum distance.</p> <code>AMOEBA_MM</code> <code>str</code> <p>Amoeba minimax.</p> <code>POWELL_LS</code> <code>str</code> <p>Powell least squares.</p> <code>POWELL_MD</code> <code>str</code> <p>Powell minimum distance.</p> <code>POWELL_MM</code> <code>str</code> <p>Powell minimax.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.Input","title":"Input  <code>dataclass</code>","text":"<pre><code>Input(\n    absolute_residuals,\n    correlated,\n    correlations,\n    delta,\n    equation,\n    fit_method,\n    max_iterations,\n    params,\n    residual_type,\n    second_derivs_B,\n    second_derivs_H,\n    tolerance,\n    ux,\n    uy,\n    uy_weights_only,\n    weighted,\n    x,\n    y,\n)\n</code></pre> <p>The input data to a fit model.</p> <p>Attributes:</p> Name Type Description <code>absolute_residuals</code> <code>bool</code> <p>Whether absolute residuals or relative residuals are used to evaluate the error-of-fit value (the standard deviation of the residuals).</p> <code>correlated</code> <code>bool</code> <p>Whether correlations are applied in the fitting process.</p> <code>correlations</code> <code>Correlations</code> <p>The information about the correlation coefficients.</p> <code>delta</code> <code>float</code> <p>Only used for Amoeba fitting.</p> <code>equation</code> <code>str</code> <p>The equation of the fit model.</p> <code>fit_method</code> <code>FitMethod</code> <p>The method that is used for the fit.</p> <code>max_iterations</code> <code>int</code> <p>The maximum number of fit iterations allowed.</p> <code>params</code> <code>InputParameters</code> <p>The input parameters to the fit model.</p> <code>residual_type</code> <code>ResidualType</code> <p>Residual Type that is used to evaluate the error-of-fit value (the standard deviation of the residuals).</p> <code>second_derivs_B</code> <code>bool</code> <p>Whether the second derivatives in the B matrix are included in the propagation of uncertainty calculations.</p> <code>second_derivs_H</code> <code>bool</code> <p>Whether the second derivatives in the curvature matrix, H (Hessian), are included in the propagation of uncertainty calculations.</p> <code>tolerance</code> <code>float</code> <p>The tolerance value to stop the fitting process.</p> <code>ux</code> <code>NDArray[float64]</code> <p>Standard uncertainties in the x (stimulus) data.</p> <code>uy</code> <code>NDArray[float64]</code> <p>Standard uncertainties in the y (response) data.</p> <code>uy_weights_only</code> <code>bool</code> <p>Whether the y uncertainties only or a combination of the x and y uncertainties are used to calculate the weights for a weighted fit.</p> <code>weighted</code> <code>bool</code> <p>Whether to include the standard uncertainties in the fitting process to perform a weighted fit.</p> <code>x</code> <code>NDArray[float64]</code> <p>The independent variable(s) (stimulus) data.</p> <code>y</code> <code>NDArray[float64]</code> <p>The dependent variable (response) data.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.ResidualType","title":"ResidualType","text":"<p>               Bases: <code>Enum</code></p> <p>Residual Type that is used to evaluate the error-of-fit value (the standard deviation of the residuals).</p> <p>Attributes:</p> Name Type Description <code>DX_X</code> <code>str</code> <p>Uncertainty in \\(x\\) versus \\(x\\).</p> <code>DX_Y</code> <code>str</code> <p>Uncertainty in \\(x\\) versus \\(y\\).</p> <code>DY_X</code> <code>str</code> <p>Uncertainty in \\(y\\) versus \\(x\\).</p> <code>DY_Y</code> <code>str</code> <p>Uncertainty in \\(y\\) versus \\(y\\).</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(\n    chisq,\n    correlation,\n    covariance,\n    dof,\n    eof,\n    iterations,\n    num_calls,\n    params,\n)\n</code></pre> <p>The result from a fit model.</p> <p>Attributes:</p> Name Type Description <code>chisq</code> <code>float</code> <p>The chi-squared value.</p> <code>correlation</code> <code>NDArray[float64]</code> <p>Parameter correlation coefficient matrix.</p> <code>covariance</code> <code>NDArray[float64]</code> <p>Parameter covariance matrix.</p> <code>dof</code> <code>float</code> <p>The number of degrees of freedom that are retained. If a fit is weighted or correlated, the degrees of freedom is \\(+\\infty\\). Otherwise, the degrees of freedom is equal to the number of data points (observations) minus the number of fit parameters.</p> <code>eof</code> <code>float</code> <p>The error-of-fit value (the standard deviation of the residuals).</p> <code>iterations</code> <code>int</code> <p>The total number of fit iterations.</p> <code>num_calls</code> <code>int</code> <p>The number of times that the fit function in the shared library was recursively called with updated best-fit parameters.</p> <code>params</code> <code>ResultParameters</code> <p>The result parameters from the fit model.</p>"},{"location":"api/datatypes/#msl.nlf.datatypes.Result.to_ureal","title":"to_ureal","text":"<pre><code>to_ureal(*, with_future=False, label='future')\n</code></pre> <p>Convert the result to a correlated ensemble of uncertain real numbers.</p> <p>Parameters:</p> Name Type Description Default <code>with_future</code> <code>bool</code> <p>Whether to include an uncertain real numbers in the ensemble that is a future indication in response to a given stimulus (a predicted future response). This reflects the variability of single indications as well as the underlying uncertainty in the fit parameters. The value of this future uncertain number is zero, and the uncertainty component is \\(\\sqrt{\\frac{\\chi^2}{dof}}\\).</p> <code>False</code> <code>label</code> <code>str</code> <p>The label to assign to the future uncertain number.</p> <code>'future'</code> <p>Returns:</p> Type Description <code>list[UncertainReal]</code> <p>A correlated ensemble of uncertain real numbers</p> <p>Examples:</p> <p>Suppose the sample data has a linear relationship</p> <pre><code>&gt;&gt;&gt; x = [3, 7, 11, 15, 18, 27, 29, 30, 30, 31, 31, 32, 33, 33, 34, 36,\n...      36, 36, 37, 38, 39, 39, 39, 40, 41, 42, 42, 43, 44, 45, 46, 47, 50]\n&gt;&gt;&gt; y = [5, 11, 21, 16, 16, 28, 27, 25, 35, 30, 40, 32, 34, 32, 34, 37,\n...      38, 34, 36, 38, 37, 36, 45, 39, 41, 40, 44, 37, 44, 46, 46, 49, 51]\n</code></pre> <p>The intercept and slope are determined from a fit</p> <pre><code>&gt;&gt;&gt; from msl.nlf import LinearModel\n&gt;&gt;&gt; with LinearModel() as model:\n...    result = model.fit(x, y)\n</code></pre> <p>We can estimate the response to a particular stimulus, say \\(x=21.5\\)</p> <pre><code>&gt;&gt;&gt; intercept, slope = result.to_ureal()\n&gt;&gt;&gt; intercept + 21.5*slope\nureal(23.257962225044...,0.82160705888850...,31.0)\n</code></pre> <p>or a single future indication in response to a given stimulus may also be of interest (again, at \\(x=21.5\\))</p> <pre><code>&gt;&gt;&gt; intercept, slope, future = result.to_ureal(with_future=True)\n&gt;&gt;&gt; intercept + 21.5*slope + future\nureal(23.257962225044...,3.33240925795711...,31.0)\n</code></pre> <p>The value here is the same as above (because the stimulus is the same), but the uncertainty is much larger, reflecting the variability of single indications as well as the underlying uncertainty in the intercept and slope.</p>"},{"location":"api/datatypes/#type-annotations","title":"Type annotations","text":"<p>Custom type annotations.</p>"},{"location":"api/datatypes/#msl.nlf._types.ArrayLike1D","title":"ArrayLike1D  <code>module-attribute</code>","text":"<pre><code>ArrayLike1D = Sequence[float] | NDArray[float64]\n</code></pre> <p>A 1-dimensional, array-like sequence.</p>"},{"location":"api/datatypes/#msl.nlf._types.ArrayLike2D","title":"ArrayLike2D  <code>module-attribute</code>","text":"<pre><code>ArrayLike2D = Sequence[Sequence[float]] | NDArray[float64]\n</code></pre> <p>A 2-dimensional, array-like sequence.</p>"},{"location":"api/datatypes/#msl.nlf._types.InputParameterType","title":"InputParameterType  <code>module-attribute</code>","text":"<pre><code>InputParameterType = (\n    InputParameter\n    | tuple[str, float]\n    | tuple[str, float, bool]\n    | tuple[str, float, bool, str | None]\n    | list[str | float | bool | None]\n    | dict[str, str | float | bool | None]\n)\n</code></pre> <p>Allowed types to create an InputParameter.</p>"},{"location":"api/loader/","title":".nlf Files","text":"<p>The Delphi GUI allows for a fit to be saved to a file, which may later be reloaded.</p> <p>The load function loads a <code>.nlf</code> file and the save method creates a <code>.nlf</code> file.</p>"},{"location":"api/loader/#msl.nlf.loader.load","title":"load","text":"<pre><code>load(path, *, win32=False)\n</code></pre> <p>Load a <code>.nlf</code> file.</p> <p>No information about the fit results are read from the file. The fit equation, the fit options and the correlation coefficients have been set in the LoadedModel that is returned, but you must specify the <code>x</code>, <code>y</code>, <code>params</code>, <code>ux</code> and/or <code>uy</code> attributes of the LoadedModel to the fit method (or you may specify different data to the fit method).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to a <code>.nlf</code> file. The file could have been created by the Delphi GUI application or by the save method.</p> required <code>win32</code> <code>bool</code> <p>Passed to the <code>win32</code> keyword argument of a Model.</p> <code>False</code> <p>Returns:</p> Type Description <code>LoadedModel</code> <p>The loaded model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from msl.nlf import load\n&gt;&gt;&gt; loaded = load(\"samples.nlf\")\n&gt;&gt;&gt; results = loaded.fit(loaded.x, loaded.y, params=loaded.params)\n</code></pre>"},{"location":"api/loader/#msl.nlf.model.LoadedModel","title":"LoadedModel","text":"<pre><code>LoadedModel(**kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A Model that was loaded from a <code>.nlf</code> file.</p> <p>Attributes:</p> Name Type Description <code>comments</code> <code>str</code> <p>Comments that were specified.</p> <code>nlf_path</code> <code>str</code> <p>The path to the <code>.nlf</code> file that was loaded.</p> <code>nlf_version</code> <code>str</code> <p>The software version that created the <code>.nlf</code> file.</p> <code>params</code> <code>InputParameters</code> <p>Input parameters to the fit model.</p> <code>ux</code> <code>NDArray[float64]</code> <p>Standard uncertainties in the \\(x\\) (stimulus) data.</p> <code>uy</code> <code>NDArray[float64]</code> <p>Standard uncertainties in the \\(y\\) (response) data.</p> <code>x</code> <code>NDArray[float64]</code> <p>The independent variable(s), \\(x\\), (stimulus) data.</p> <code>y</code> <code>NDArray[float64]</code> <p>The dependent variable, \\(y\\), (response) data.</p> <p>Do not instantiate this class directly. The proper way to load a <code>.nlf</code> file is via the load function.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/model/","title":"Generic Model","text":"<p>A model to use for a non-linear fit.</p>"},{"location":"api/model/#msl.nlf.model.Model","title":"Model","text":"<pre><code>Model(equation, *, user_dir=None, win32=False, **options)\n</code></pre> <p>A model for non-linear fitting.</p> <p>Parameters:</p> Name Type Description Default <code>equation</code> <code>str</code> <p>The fit equation. The \\(x\\) variables (stimulus) must be specified as <code>x1</code>, <code>x2</code>, etc. and the parameters as <code>a1</code>, <code>a2</code>, etc. If only one \\(x\\)-variable is required, it can be simply specified as <code>x</code>.</p> <p>The arithmetic operations that are recognised are: <code>+ - * / ^</code></p> <p>where <code>^</code> indicates raising to the power.</p> <p>The mathematical functions that are recognised are: <code>sin cos tan exp ln log arcsin arcos</code></p> <p>The <code>sqrt</code> function should be written as <code>^0.5</code>, for example, <code>sqrt(2*x)</code> would be expressed as <code>(2*x)^0.5</code> in the equation.</p> <p>You may use <code>pi</code> to represent the numeric value <code>3.141592653589793</code>.</p> <p>All white space is ignored in the equation.</p> <p>Only round brackets <code>(</code> and <code>)</code> may be used. The brackets can be nested, for example, <code>a1*(x+a2*(x-a3*(x/(1-a4))))</code>.</p> <p>If using a compiled (user-defined) function, the equation value must begin with <code>f</code> and is followed by a positive integer, for example, <code>\"f1\"</code>. The <code>user_dir</code> keyword argument may also need to be specified.</p> required <code>user_dir</code> <code>str | Path | None</code> <p>Directory where the compiled (user-defined) function are located. The default directory is the directory that the Delphi GUI has set. If the Delphi GUI has not set a directory (because the GUI has not been used) the default directory is the current working directory.</p> <code>None</code> <code>win32</code> <code>bool</code> <p>Whether to load the 32-bit non-linear-fitting library in 64-bit Python. See the 32-bit Compiled Function section for reasons why you may want to enable this feature. Available on Windows only.</p> <code>False</code> <code>**options</code> <code>Any</code> <p>All additional keyword arguments are passed to options.</p> <code>{}</code>"},{"location":"api/model/#msl.nlf.model.Model.delphi_library","title":"delphi_library  <code>property</code>","text":"<pre><code>delphi_library\n</code></pre> <p>Returns the path to the Delphi shared-library file.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shared library.</p>"},{"location":"api/model/#msl.nlf.model.Model.equation","title":"equation  <code>property</code>","text":"<pre><code>equation\n</code></pre> <p>Returns the fitting equation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The fit equation.</p>"},{"location":"api/model/#msl.nlf.model.Model.num_parameters","title":"num_parameters  <code>property</code>","text":"<pre><code>num_parameters\n</code></pre> <p>Returns the number of fit parameters in the equation.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of fit parameters.</p>"},{"location":"api/model/#msl.nlf.model.Model.num_variables","title":"num_variables  <code>property</code>","text":"<pre><code>num_variables\n</code></pre> <p>Returns the number of \\(x\\) (stimulus) variables in the equation.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of independent variables.</p>"},{"location":"api/model/#msl.nlf.model.Model.show_warnings","title":"show_warnings  <code>property</code> <code>writable</code>","text":"<pre><code>show_warnings\n</code></pre> <p>Whether warning messages are shown.</p> <p>Warnings are shown if correlations are defined and the fit option is set to be uncorrelated, or if <code>ux</code> or <code>uy</code> are specified and the fit option is unweighted, or if the maximum number of fit iterations has been exceeded.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether warning messages are shown.</p>"},{"location":"api/model/#msl.nlf.model.Model.user_function_name","title":"user_function_name  <code>property</code>","text":"<pre><code>user_function_name\n</code></pre> <p>Returns the name of the user-defined function.</p> <p>This is the value that GetFunctionName returns. If a user-defined function is not used, an empty string is returned. See compiled (user-defined) function.</p>"},{"location":"api/model/#msl.nlf.model.Model.create_parameters","title":"create_parameters  <code>staticmethod</code>","text":"<pre><code>create_parameters(parameters=None)\n</code></pre> <p>Create a new collection of InputParameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Iterable[InputParameterType] | None</code> <p>An iterable of either InputParameter instances or objects that can be used to create an InputParameter instance. See add_many for examples. If not specified, an empty collection is returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>The input parameters.</p>"},{"location":"api/model/#msl.nlf.model.Model.evaluate","title":"evaluate","text":"<pre><code>evaluate(x, result)\n</code></pre> <p>Evaluate the model to get the <code>y</code> (response) values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D | ArrayLike2D</code> <p>The independent variable (stimulus) data to evaluate the model at. If the model requires multiple variables, the <code>x</code> array must have a shape of <code>(# variables, # points)</code>, i.e., the data for each variable is listed per row <code>[ [data for x1], [data for x2], ... ]</code></p> required <code>result</code> <code>Result | dict[str, float]</code> <p>The fit Result or a mapping between parameter names and values, e.g., <code>{\"a1\": 9.51, \"a2\": -0.076, \"a3\": 0.407}</code></p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The <code>y</code> (response) values.</p>"},{"location":"api/model/#msl.nlf.model.Model.fit","title":"fit","text":"<pre><code>fit(\n    x: ArrayLike1D | ArrayLike2D,\n    y: ArrayLike1D,\n    *,\n    params: ArrayLike1D | InputParameters | None = None,\n    ux: ArrayLike1D | ArrayLike2D | None = None,\n    uy: ArrayLike1D | None = None,\n    debug: Literal[False] = False,\n    **options: Any\n) -&gt; Result\n</code></pre><pre><code>fit(\n    x: ArrayLike1D | ArrayLike2D,\n    y: ArrayLike1D,\n    *,\n    params: ArrayLike1D | InputParameters | None = None,\n    ux: ArrayLike1D | ArrayLike2D | None = None,\n    uy: ArrayLike1D | None = None,\n    debug: Literal[True],\n    **options: Any\n) -&gt; Input\n</code></pre> <pre><code>fit(\n    x,\n    y,\n    *,\n    params=None,\n    ux=None,\n    uy=None,\n    debug=False,\n    **options\n)\n</code></pre> <p>Fit the model to the data.</p> Tip <p>It is more efficient to use a numpy.ndarray rather than a list/tuple for the <code>x</code>, <code>y</code>, <code>ux</code> and <code>uy</code> arrays.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D | ArrayLike2D</code> <p>The independent variable (stimulus) data. If the model requires multiple variables, the <code>x</code> array must have a shape of <code>(# variables, # points)</code>, i.e., the data for each variable is listed per row</p> <p><code>[ [data for x1], [data for x2], ... ]</code></p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>params</code> <code>ArrayLike1D | InputParameters | None</code> <p>Fit parameters. If an array is passed in then every parameter will be allowed to vary during the fit. If you want more control, pass in an InputParameters instance. If not specified, the parameters are chosen from the guess method.</p> <code>None</code> <code>ux</code> <code>ArrayLike1D | ArrayLike2D | None</code> <p>Standard uncertainties in the <code>x</code> data.</p> <code>None</code> <code>uy</code> <code>ArrayLike1D | None</code> <p>Standard uncertainties in the <code>y</code> data.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If enabled, a summary of the input data that would be passed to the non-linear fit algorithm is returned (the algorithm is not called). Enabling this parameter is useful for debugging issues if the algorithm raises an error or if the fit result is unexpected (e.g., the data points with smaller uncertainties are not having a stronger influence on the result, perhaps because an unweighted fit has been selected as one of the fit options).</p> <code>False</code> <code>**options</code> <code>Any</code> <p>All additional keyword arguments are passed to options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result | Input</code> <p>The returned type depends on whether <code>debug</code> mode is enabled or disabled. If <code>debug=True</code>, an Input object is returned, otherwise a Result object is returned.</p>"},{"location":"api/model/#msl.nlf.model.Model.guess","title":"guess","text":"<pre><code>guess(x, y, **kwargs)\n</code></pre> <p>Generate an initial guess for the parameters of a Model.</p> Note <p>This method must be overridden in the subclass.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D | ArrayLike2D</code> <p>The independent variable (stimulus) data. If the model requires multiple variables, the <code>x</code> array must have a shape of <code>(# variables, # points)</code>, i.e., the data for each variable is listed per row</p> <p><code>[ [data for x1], [data for x2], ... ]</code></p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>**kwargs</code> <code>Any</code> <p>All additional keyword arguments are passed to the subclass.</p> <code>{}</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess parameters. Each constant value is set to <code>False</code> and a label is chosen by the subclass. The values of these attributes can be changed by the user in the returned InputParameters object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the <code>guess</code> method has not been overridden.</p>"},{"location":"api/model/#msl.nlf.model.Model.options","title":"options","text":"<pre><code>options(\n    *,\n    absolute_residuals=None,\n    correlated=None,\n    delta=None,\n    max_iterations=None,\n    fit_method=None,\n    residual_type=None,\n    second_derivs_B=None,\n    second_derivs_H=None,\n    tolerance=None,\n    uy_weights_only=None,\n    weighted=None\n)\n</code></pre> <p>Configure the fitting options.</p> <p>Only the parameters that are specified are updated. If you call this method multiple times, the parameters specified in a previous call will still be used if the parameters are not reset.</p> <p>Parameters:</p> Name Type Description Default <code>absolute_residuals</code> <code>bool | None</code> <p>Whether absolute residuals or relative residuals are used to evaluate the error-of-fit value (the standard deviation of the residuals). Default is <code>True</code> (absolute).</p> <code>None</code> <code>correlated</code> <code>bool | None</code> <p>Whether to include the correlations in the fitting process. Including correlations in the fit is only possible for least-squares fitting, in which case the fit becomes a generalised least-squares fit. The correlations between the correlated variables can be set by calling set_correlation or set_correlation_dir. Default is <code>False</code>.</p> <code>None</code> <code>delta</code> <code>float | None</code> <p>Only used for Amoeba fitting. Default is <code>0.1</code>.</p> <code>None</code> <code>max_iterations</code> <code>int | None</code> <p>The maximum number of fit iterations allowed. Default is <code>999</code>.</p> <code>None</code> <code>fit_method</code> <code>FitMethod | str | None</code> <p>The fitting method to use. Can be a member name or value of the FitMethod enum. Default is <code>Levenberg-Marquardt</code>.</p> <code>None</code> <code>residual_type</code> <code>ResidualType | str | None</code> <p>The residual type to use to evaluate the error-of-fit value (the standard deviation of the residuals). Can be a member name or value of the ResidualType enum. Default is <code>DY_X</code> (uncertainty in \\(y\\) versus \\(x\\)).</p> <code>None</code> <code>second_derivs_B</code> <code>bool | None</code> <p>Whether the second derivatives in the B matrix are included in the propagation of uncertainty calculations. Default is <code>True</code>.</p> <code>None</code> <code>second_derivs_H</code> <code>bool | None</code> <p>Whether the second derivatives in the curvature matrix, H (Hessian), are included in the propagation of uncertainty calculations. Default is <code>True</code>.</p> <code>None</code> <code>tolerance</code> <code>float | None</code> <p>The fitting process will stop when the relative change in \\({\\chi}^2\\) (or another defined measure) is less than this value. Default is <code>1e-20</code>.</p> <code>None</code> <code>uy_weights_only</code> <code>bool | None</code> <p>Whether only the <code>y</code> uncertainties or a combination of the <code>x</code> and <code>y</code> uncertainties are used to calculate the weights for a weighted fit. Default is <code>False</code>.</p> <code>None</code> <code>weighted</code> <code>bool | None</code> <p>Whether to include the standard uncertainties in the fitting process to perform a weighted fit. Default is <code>False</code>.</p> <code>None</code>"},{"location":"api/model/#msl.nlf.model.Model.remove_correlations","title":"remove_correlations","text":"<pre><code>remove_correlations()\n</code></pre> <p>Set all variables to be uncorrelated.</p>"},{"location":"api/model/#msl.nlf.model.Model.save","title":"save","text":"<pre><code>save(\n    path,\n    *,\n    x=None,\n    y=None,\n    params=None,\n    ux=None,\n    uy=None,\n    comments=None,\n    overwrite=False\n)\n</code></pre> <p>Save a .nlf file.</p> <p>The file can be opened in the Delphi GUI application or loaded via the load function.</p> <p>No information about the fit results are written to the file. If you are opening the file in the Delphi GUI, you must click the Calculate button to perform the fit and create the graphs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to save the file to. The file extension must be <code>.nlf</code>.</p> required <code>x</code> <code>ArrayLike1D | ArrayLike2D | None</code> <p>The independent variable (stimulus) data. If not specified, the data that was most recently passed to fit or a previous call to save is used.</p> <code>None</code> <code>y</code> <code>ArrayLike1D | None</code> <p>The dependent variable (response) data. If not specified, the data that was most recently passed to fit or a previous call to save is used.</p> <code>None</code> <code>params</code> <code>ArrayLike1D | InputParameters | None</code> <p>Fit parameters. If not specified, the parameters that were most recently passed to fit or a previous call to save are used. Since the Delphi GUI application does not use the label attribute, the labels are not saved and will be <code>None</code> when the file is reloaded.</p> <code>None</code> <code>ux</code> <code>ArrayLike1D | ArrayLike2D | None</code> <p>Standard uncertainties in the \\(x\\) data. If not specified, the data that was most recently passed to fit is used.</p> <code>None</code> <code>uy</code> <code>ArrayLike1D | None</code> <p>Standard uncertainties in the \\(y\\) data. If not specified, the data that was most recently passed to fit is used.</p> <code>None</code> <code>comments</code> <code>str | None</code> <p>Additional comments to add to the file. This text will appear in the Comments window in the Delphi GUI application.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it already exists. If the file exists, and this value is <code>False</code> then an error is raised.</p> <code>False</code>"},{"location":"api/model/#msl.nlf.model.Model.set_correlation","title":"set_correlation","text":"<pre><code>set_correlation(name1, name2, correlation)\n</code></pre> <p>Set the correlation coefficients for the correlated variables.</p> <p>Note that the <code>x1-x2</code> correlation coefficients are identically equal to the <code>x2-x1</code> correlation coefficients, so only one of these relations needs to be defined.</p> Warning <p>It is recommended to not call set_correlation and set_correlation_dir with the same Model instance. Pick only one method. If you set correlations using both methods an error will not be raised, but you may be surprised which correlations are used.</p> <p>Parameters:</p> Name Type Description Default <code>name1</code> <code>str</code> <p>The name of the first correlated variable (e.g., <code>y</code>, <code>x</code>, <code>x1</code>, <code>x2</code>).</p> required <code>name2</code> <code>str</code> <p>The name of the second correlated variable.</p> required <code>correlation</code> <code>float | ArrayLike2D</code> <p>If a <code>float</code> then all off-diagonal coefficients in the correlation matrix will be set to this value, otherwise the 2D correlation matrix.</p> required"},{"location":"api/model/#msl.nlf.model.Model.set_correlation_dir","title":"set_correlation_dir","text":"<pre><code>set_correlation_dir(directory)\n</code></pre> <p>Set the directory where the correlation coefficients are located.</p> <p>The directory should contain correlation-coefficient files that must be named <code>CorrCoeffs Y-Y.txt</code>, <code>CorrCoeffs X1-X1.txt</code>, <code>CorrCoeffs X1-X2.txt</code>, etc. Note that the <code>X1-X2</code> correlation coefficients are identically equal to the <code>X2-X1</code> correlation coefficients, so only one of the files <code>CorrCoeffs X1-X2.txt</code> or <code>CorrCoeffs X2-X1.txt</code> needs to be created.</p> <p>Whitespace is used to separate the value for each column in a file.</p> Warning <p>It is recommended to not mix set_correlation and set_correlation_dir with the same Model instance. Pick only one method. If you set correlations using both methods an error will not be raised, but you may be surprised which correlations are used.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path | None</code> <p>The directory (folder) where the correlation coefficients are located. Specify <code>\".\"</code> for the current working directory.</p> required"},{"location":"api/model/#msl.nlf.model.Model.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Get the version number of the Delphi shared library.</p> <p>Returns:</p> Type Description <code>str</code> <p>The library version number.</p>"},{"location":"api/models/","title":"Built-in Models","text":"<p>Built-in models.</p>"},{"location":"api/models/#msl.nlf.models.ConstantModel","title":"ConstantModel","text":"<pre><code>ConstantModel(**kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on a constant.</p> <p>The function is defined as</p> \\[f(x; a) = a_1\\] <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.ConstantModel.guess","title":"guess","text":"<pre><code>guess(x, y, *, n=None)\n</code></pre> <p>Calculates the mean value of <code>y</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D | ArrayLike2D</code> <p>The independent variable (stimulus) data. The data is not used.</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>n</code> <code>int | None</code> <p>The number of values in <code>y</code> to use to calculate the mean. If not specified, all values are used. If a positive integer then the first <code>n</code> values are used, otherwise, the last <code>n</code> values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the constant.</p>"},{"location":"api/models/#msl.nlf.models.ExponentialModel","title":"ExponentialModel","text":"<pre><code>ExponentialModel(*, cumulative=False, **kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on an exponential function.</p> <p>The non-cumulative function is defined as</p> \\[f(x; a) = a_1 e^{-a_2 x}\\] <p>whereas, the cumulative function is defined as</p> \\[f(x; a) = a_1 (1-e^{-a_2 x})\\] <p>Parameters:</p> Name Type Description Default <code>cumulative</code> <code>bool</code> <p>Whether to use the cumulative function.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.ExponentialModel.guess","title":"guess","text":"<pre><code>guess(x, y, *, n=3)\n</code></pre> <p>Linearizes the equation and calls the polyfit function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D</code> <p>The independent variable (stimulus) data.</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>n</code> <code>int</code> <p>For a cumulative equation, uses the maximum <code>n</code> values in <code>y</code> to calculate the mean and assigns the mean value as the amplitude guess.</p> <code>3</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the amplitude and decay factor.</p>"},{"location":"api/models/#msl.nlf.models.GaussianModel","title":"GaussianModel","text":"<pre><code>GaussianModel(*, normalized=False, **kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on a Gaussian function or a normal distribution.</p> <p>The non-normalized function is defined as</p> \\[f(x; a) = a_1 e^{-\\frac{1}{2}(\\frac{x-a_2}{a_3})^2}\\] <p>whereas, the normalized function is defined as</p> \\[f(x; a) = \\frac{a_1}{a_3\\sqrt{2\\pi}} e^{-\\frac{1}{2}(\\frac{x-a_2}{a_3})^2}\\] <p>Parameters:</p> Name Type Description Default <code>normalized</code> <code>bool</code> <p>Whether to use the normalized function.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>All additional keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.GaussianModel.guess","title":"guess","text":"<pre><code>guess(x, y, *, n=3)\n</code></pre> <p>Converts the data to a quadratic and calls the polyfit function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D</code> <p>The independent variable (stimulus) data.</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>n</code> <code>int</code> <p>Uses the <code>n</code> maximum and the <code>n</code> minimum values in <code>y</code> to determine the region where the peak/dip is located.</p> <code>3</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the amplitude (area), \\(\\mu\\) and \\(\\sigma\\) parameters.</p>"},{"location":"api/models/#msl.nlf.models.LinearModel","title":"LinearModel","text":"<pre><code>LinearModel(**kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on a linear function.</p> <p>The function is defined as</p> \\[f(x; a) = a_1 + a_2 x\\] <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.LinearModel.guess","title":"guess","text":"<pre><code>guess(x, y, **kwargs)\n</code></pre> <p>Calls the polyfit function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D</code> <p>The independent variable (stimulus) data.</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>**kwargs</code> <code>Any</code> <p>Ignored. No keyword arguments are used.</p> <code>{}</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the intercept and slope.</p>"},{"location":"api/models/#msl.nlf.models.PolynomialModel","title":"PolynomialModel","text":"<pre><code>PolynomialModel(n, **kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on a polynomial function.</p> <p>The function is defined as</p> \\[f(x; a) = \\sum_{i=1}^{n} a_i x^{i-1}\\] <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The order of the polynomial (n \\(\\geq\\) 1).</p> required <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.PolynomialModel.guess","title":"guess","text":"<pre><code>guess(x, y, **kwargs)\n</code></pre> <p>Calls the polyfit function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D</code> <p>The independent variable (stimulus) data.</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>**kwargs</code> <code>Any</code> <p>Ignored. No keyword arguments are used.</p> <code>{}</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the polynomial coefficients.</p>"},{"location":"api/models/#msl.nlf.models.SineModel","title":"SineModel","text":"<pre><code>SineModel(*, angular=False, **kwargs)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>A model based on a sine function.</p> <p>If <code>angular</code> is <code>False</code> (default), the function is defined as</p> \\[f(x; a) = a_1 \\sin(2 \\pi a_2 x + a_3)\\] <p>and \\(a_2\\) represents the frequency of oscillation, otherwise</p> \\[f(x; a) = a_1 \\sin(a_2 x + a_3)\\] <p>and \\(a_2\\) represents the angular frequency.</p> <p>Parameters:</p> Name Type Description Default <code>angular</code> <code>bool</code> <p>Whether to use angular frequency in the equation.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>All keyword arguments are passed to Model.</p> <code>{}</code>"},{"location":"api/models/#msl.nlf.models.SineModel.guess","title":"guess","text":"<pre><code>guess(x, y, *, uniform=True, n=11)\n</code></pre> <p>Uses an FFT to determine the amplitude and angular frequency.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike1D</code> <p>The independent variable (stimulus) data. The <code>x</code> data must be sorted (smallest to largest).</p> required <code>y</code> <code>ArrayLike1D</code> <p>The dependent variable (response) data.</p> required <code>uniform</code> <code>bool</code> <p>Whether the <code>x</code> data has uniform spacing between each value.</p> <code>True</code> <code>n</code> <code>int</code> <p>The number of sub-intervals to break up [0, \\(2\\pi\\)) to determine the phase guess.</p> <code>11</code> <p>Returns:</p> Type Description <code>InputParameters</code> <p>Initial guess for the amplitude, angular frequency and phase.</p>"},{"location":"api/parameters/","title":"Parameters","text":"<p>Parameters are used as inputs to and results from a fit model.</p>"},{"location":"api/parameters/#msl.nlf.parameters.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', InputParameter, ResultParameter)\n</code></pre> <p>Generic parameter type.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameter","title":"InputParameter","text":"<pre><code>InputParameter(name, value, *, constant=False, label=None)\n</code></pre> <p>               Bases: <code>Parameter</code></p> <p>A parameter to use as an input to a fit model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> required <code>value</code> <code>float</code> <p>The value of the parameter.</p> required <code>constant</code> <code>bool</code> <p>Whether the parameter is held constant (<code>True</code>) or allowed to vary (<code>False</code>) during the fitting process.</p> <code>False</code> <code>label</code> <code>str | None</code> <p>A custom label associated with the parameter. For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <code>None</code>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameter.constant","title":"constant  <code>property</code> <code>writable</code>","text":"<pre><code>constant\n</code></pre> <p>Whether the parameter is held constant (<code>True</code>) or allowed to vary (<code>False</code>) during the fitting process.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the parameter is held constant.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameter.label","title":"label  <code>property</code> <code>writable</code>","text":"<pre><code>label\n</code></pre> <p>A custom label associated with the parameter.</p> <p>For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The label.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameter.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the parameter.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameter.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>The value of the parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>The value.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters","title":"InputParameters","text":"<pre><code>InputParameters(parameters=None)\n</code></pre> <p>               Bases: <code>Parameters[InputParameter]</code></p> <p>A collection of InputParameters for a fit model.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Iterable[InputParameterType] | None</code> <p>An iterable of either InputParameter instances or objects that can be used to create an InputParameter instance. See add for examples.</p> <code>None</code>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.add","title":"add","text":"<pre><code>add(*args, **kwargs)\n</code></pre> <p>Add an InputParameter.</p> <p>An InputParameter can be added using either positional or keyword arguments, but you cannot use both simultaneously. You can specify positional arguments by using one of four options:</p> <ul> <li>InputParameter (a single argument must be an InputParameter)</li> <li>name, value</li> <li>name, value, constant</li> <li>name, value, constant, label</li> </ul> <p>You could alternatively add an InputParameter in the same way that you add items to a dict.</p> <p>Returns:</p> Type Description <code>InputParameter</code> <p>The input parameter that was added.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from msl.nlf import InputParameter, InputParameters\n&gt;&gt;&gt; params = InputParameters()\n&gt;&gt;&gt; a1 = params.add(\"a1\", 1)\n&gt;&gt;&gt; a2 = params.add(\"a2\", 0.34, True)\n&gt;&gt;&gt; a3 = params.add(\"a3\", -1e3, False, \"offset\")\n&gt;&gt;&gt; a4 = params.add(name=\"a4\", value=3.14159, constant=True, label=\"pi\")\n&gt;&gt;&gt; a5 = params.add(name=\"a5\", value=100)\n&gt;&gt;&gt; a6 = params.add(InputParameter(\"a6\", 32.0))\n&gt;&gt;&gt; params[\"a7\"] = InputParameter(\"a7\", 7, constant=True)\n&gt;&gt;&gt; params[\"a8\"] = 88.8\n&gt;&gt;&gt; params[\"a9\"] = (-1, True)\n&gt;&gt;&gt; params[\"a10\"] = {\"value\": 0, \"label\": \"intercept\"}\n&gt;&gt;&gt; for param in params:\n...     print(f\"{param.name}={param.value}\")\na1=1.0\na2=0.34\na3=-1000.0\na4=3.14159\na5=100.0\na6=32.0\na7=7.0\na8=88.8\na9=-1.0\na10=0.0\n</code></pre>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.add_many","title":"add_many","text":"<pre><code>add_many(parameters)\n</code></pre> <p>Add many InputParameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Iterable[InputParameterType]</code> <p>An iterable of either InputParameter instances or objects that can be used to create an InputParameter instance. See add for more examples.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from msl.nlf import InputParameter, InputParameters\n&gt;&gt;&gt; inputs = (InputParameter(\"a1\", 1),\n...           (\"a2\", 2, True),\n...           {\"name\": \"a3\", \"value\": 3})\n&gt;&gt;&gt; params = InputParameters()\n&gt;&gt;&gt; params.add_many(inputs)\n&gt;&gt;&gt; for param in params:\n...     print(param)\nInputParameter(name='a1', value=1.0, constant=False, label=None)\nInputParameter(name='a2', value=2.0, constant=True, label=None)\nInputParameter(name='a3', value=3.0, constant=False, label=None)\n</code></pre>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Remove all InputParameters from the collection.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.constants","title":"constants","text":"<pre><code>constants()\n</code></pre> <p>Returns the constant of each parameter.</p> <p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>A list of constants.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.labels","title":"labels","text":"<pre><code>labels()\n</code></pre> <p>Returns the label of each parameter.</p> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>A list of labels.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.names","title":"names","text":"<pre><code>names()\n</code></pre> <p>Returns the name of each parameter.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of names.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.pop","title":"pop","text":"<pre><code>pop(name_or_label)\n</code></pre> <p>Pop an InputParameter from the collection.</p> <p>This will remove the InputParameter from the collection and return it.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_label</code> <code>str</code> <p>The name or label of an InputParameter</p> required <p>Returns:</p> Type Description <code>InputParameter</code> <p>The input parameter that was popped.</p>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.update","title":"update","text":"<pre><code>update(name_or_label, **attribs)\n</code></pre> <p>Update the attributes of an InputParameter.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_label</code> <code>str</code> <p>The name or label of an InputParameter</p> required <code>**attribs</code> <code>Any</code> <p>The new attributes.</p> <code>{}</code> <p>Examples:</p> <p>First, add a parameter</p> <pre><code>&gt;&gt;&gt; from msl.nlf import InputParameters\n&gt;&gt;&gt; params = InputParameters()\n&gt;&gt;&gt; a1 = params.add(\"a1\", 1)\n&gt;&gt;&gt; a1\nInputParameter(name='a1', value=1.0, constant=False, label=None)\n</code></pre> <p>then update it by calling the :meth:<code>.update</code> method</p> <pre><code>&gt;&gt;&gt; params.update(\"a1\", value=0, constant=True, label=\"intercept\")\n&gt;&gt;&gt; a1\nInputParameter(name='a1', value=0.0, constant=True, label='intercept')\n</code></pre> <p>Alternatively, you can update a parameter by directly modifying an attribute</p> <pre><code>&gt;&gt;&gt; a1.label = \"something-new\"\n&gt;&gt;&gt; a1.constant = False\n&gt;&gt;&gt; a1.value = -3.2\n&gt;&gt;&gt; params[\"a1\"]\nInputParameter(name='a1', value=-3.2, constant=False, label='something-new')\n</code></pre>"},{"location":"api/parameters/#msl.nlf.parameters.InputParameters.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Returns the value of each parameter.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A list of values.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameter","title":"Parameter","text":"<pre><code>Parameter(name, value, *, label=None)\n</code></pre> <p>A generic parameter used as an input to or a result from a fit model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> required <code>value</code> <code>float</code> <p>The value of the parameter.</p> required <code>label</code> <code>str | None</code> <p>A custom label associated with the parameter. For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <code>None</code>"},{"location":"api/parameters/#msl.nlf.parameters.Parameter.label","title":"label  <code>property</code> <code>writable</code>","text":"<pre><code>label\n</code></pre> <p>A custom label associated with the parameter.</p> <p>For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The label.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameter.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the parameter.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameter.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>The value of the parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>The value.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameters","title":"Parameters","text":"<pre><code>Parameters()\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Base class for a collection of parameters.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameters.labels","title":"labels","text":"<pre><code>labels()\n</code></pre> <p>Returns the label of each parameter.</p> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>A list of labels.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameters.names","title":"names","text":"<pre><code>names()\n</code></pre> <p>Returns the name of each parameter.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of names.</p>"},{"location":"api/parameters/#msl.nlf.parameters.Parameters.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Returns the value of each parameter.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A list of values.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameter","title":"ResultParameter","text":"<pre><code>ResultParameter(name, value, uncert, *, label=None)\n</code></pre> <p>               Bases: <code>Parameter</code></p> <p>A parameter that is returned from a fit model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> required <code>value</code> <code>float</code> <p>The value of the parameter.</p> required <code>uncert</code> <code>float</code> <p>The standard uncertainty of the parameter.</p> required <code>label</code> <code>str | None</code> <p>A custom label associated with the parameter. For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <code>None</code>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameter.label","title":"label  <code>property</code> <code>writable</code>","text":"<pre><code>label\n</code></pre> <p>A custom label associated with the parameter.</p> <p>For example, if the fit equation is <code>a1+a2*x</code>, you could assign a label of intercept to <code>a1</code> and slope to <code>a2</code>.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The label.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameter.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre> <p>The name of the parameter in the equation (e.g., <code>a1</code>).</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the parameter.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameter.uncert","title":"uncert  <code>property</code> <code>writable</code>","text":"<pre><code>uncert\n</code></pre> <p>The standard uncertainty of the parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>The standard uncertainty.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameter.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>The value of the parameter.</p> <p>Returns:</p> Type Description <code>float</code> <p>The value.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameters","title":"ResultParameters","text":"<pre><code>ResultParameters(result, params)\n</code></pre> <p>               Bases: <code>Parameters[ResultParameter]</code></p> <p>A collection of ResultParameters from a fit model.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>dict[str, Any]</code> <p>The result from a fit model.</p> required <code>params</code> <code>InputParameters</code> <p>The input parameters to the fit model.</p> required"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameters.labels","title":"labels","text":"<pre><code>labels()\n</code></pre> <p>Returns the label of each parameter.</p> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>A list of labels.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameters.names","title":"names","text":"<pre><code>names()\n</code></pre> <p>Returns the name of each parameter.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of names.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameters.uncerts","title":"uncerts","text":"<pre><code>uncerts()\n</code></pre> <p>Returns the uncert of each parameter.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A list of uncerts.</p>"},{"location":"api/parameters/#msl.nlf.parameters.ResultParameters.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Returns the value of each parameter.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A list of values.</p>"},{"location":"examples/damped_oscillator_composite/","title":"Composite Model","text":"<p>In this example, a composite model is created using built-in models to create a model for a damped oscillator (underdamped case).</p> <p>The equation for the underdamped oscillator is</p> \\[ f(x; a) = a_1 e^{-a_2 x} \\sin(2 \\pi a_3 x + a_4) + a_5 \\] <p>First, simulate some noisy data (we can also see what the expected results of the \\(a_i\\) parameters are)</p> <pre><code>import numpy as np\n\nx = np.linspace(0, 1, num=200)\nnoise = np.random.normal(scale=0.15, size=x.size)\ny = 2.6 * np.exp(-4.3*x) * np.sin(2*np.pi*7.68*x + 0.5) + 0.7 + noise\n</code></pre> <p>Next, set up the model by creating a composite model from built-in models, create the initial-guess parameters and apply the fit</p> <pre><code>from msl.nlf import ExponentialModel, SineModel, ConstantModel\n\n# Create the composite model\nmodel = ExponentialModel() * SineModel() + ConstantModel()\n\n# Equivalently, one could have explicitly written the equation\n# model = Model(\"a1*exp(-a2*x)*sin(2*pi*a3*x+a4)+a5\")\n\n# Create the initial-guess parameters. All are allowed to vary during the\n# fitting process and assign helpful labels\nparams = model.create_parameters()\nparams[\"a1\"] = {\"value\": 1, \"label\": \"amplitude\"}\nparams[\"a2\"] = {\"value\": 1, \"label\": \"damping\"}\nparams[\"a3\"] = {\"value\": 10, \"label\": \"frequency\"}\nparams[\"a4\"] = {\"value\": 0, \"label\": \"phase\"}\nparams[\"a5\"] = {\"value\": 0, \"label\": \"offset\"}\n\n# Apply the fit\nresult = model.fit(x, y, params=params)\n</code></pre> <p>Print the result parameters (you can compare with the expected values above, ignoring the noise)</p> <pre><code>print(result.params)\n</code></pre> <pre><code>ResultParameters(\n  ResultParameter(name='a1', value=2.6369351294736645, uncert=0.060704297013533415, label='amplitude'),\n  ResultParameter(name='a2', value=4.390074971859298, uncert=0.14847647852269052, label='damping'),\n  ResultParameter(name='a3', value=7.649234983143321, uncert=0.02483505385419107, label='frequency'),\n  ResultParameter(name='a4', value=0.5587512518277815, uncert=0.0257567281236547, label='phase'),\n  ResultParameter(name='a5', value=0.6836661973420295, uncert=0.0109111393141931, label='offset')\n)\n</code></pre> <p>The following requires Matplotlib to be installed. If it is not already install, you may run</p> <pre><code>pip install matplotlib\n</code></pre> <p>Using the evaluate method, plot the data and the fit curve</p> <pre><code>import matplotlib.pyplot as plt\n\n# Evaluate the fit curve from the \"result\" object\nx_fit = np.linspace(np.min(x), np.max(x), num=1000)\ny_fit = model.evaluate(x_fit, result)\n\n# Plot the data and the fit\nplt.scatter(x, y, c=\"blue\")\nplt.plot(x_fit, y_fit, c=\"red\")\nplt.show()\n</code></pre> <p> </p>"},{"location":"examples/gtc/","title":"Uncertain Real Numbers (GTC)","text":"<p>This example requires GTC to be installed. If it is not already installed, you may run</p> <pre><code>pip install GTC\n</code></pre> <p>This example uses the calibration curve that is defined in Appendix H3 of the GUM<sup>1</sup></p> \\[ b(t) = y_1 + y_2 (t-t_0) \\] <p>where the reference temperature, \\(t_0\\), is chosen to be 20 \\(^\\circ \\mathrm{C}\\).</p> <p>This calibration curve translates to the following equation that is passed to a Model</p> \\[ f(x; a) = a_1 + a_2 (x-20) \\] <p>The intercept (\\(a_1\\)) and slope (\\(a_2\\)) result parameters are converted to a correlated ensemble of uncertain real numbers (via the to_ureal method) which are used to calculate the response at a chosen stimulus.</p> <pre><code>from msl.nlf import Model\n\n# Thermometer readings (degrees C)\nx = (21.521, 22.012, 22.512, 23.003, 23.507,\n     23.999, 24.513, 25.002, 25.503, 26.010, 26.511)\n\n# Observed differences with calibration standard (degrees C)\ny = (-0.171, -0.169, -0.166, -0.159, -0.164,\n     -0.165, -0.156, -0.157, -0.159, -0.161, -0.160)\n\n# Arbitrary offset temperature (degrees C)\nt0 = 20\n\n# Create the model\nmodel = Model(f\"a1+a2*(x-{t0})\")\n\n# Create an initial guess. Allow the intercept and slope to vary during\n# the fitting process and assign helpful labels\nparams = model.create_parameters([\n    (\"a1\", 1, False, \"intercept\"),\n    (\"a2\", 1, False, \"slope\")\n])\n\n# Apply the fit\nresult = model.fit(x, y, params=params)\n\n# Convert the result to a correlated ensemble of uncertain real numbers\nintercept, slope = result.to_ureal()\n</code></pre> <p>The intercept and slope can be used to calculate a correction for a reading of 30 \\(^\\circ \\mathrm{C}\\)</p> <pre><code>&gt;&gt;&gt; intercept + slope*(30 - t0)\nureal(-0.14937681268874...,0.004138595752854...,9.0)\n</code></pre> <ol> <li> <p>BIPM and IEC and IFCC and ISO and IUPAC and IUPAP and OIML, Evaluation of measurement data - Guide to the expression of uncertainty in measurement JCGM 100:2008 (GUM 1995 with minor corrections).\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/matplotlib/","title":"Plotting Results (Matplotlib)","text":"<p>This example requires Matplotlib to be installed. If it is not already install, you may run</p> <pre><code>pip install matplotlib\n</code></pre> <p>A LinearModel is used to perform the weighted fit. An initial guess is automatically generated (i.e., no params are passed to the fit method). Using the evaluate method, the fit line and the residuals are evaluated.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom msl.nlf import LinearModel\n\n# Sample data\nx = np.array([1.6, 3.2, 5.5, 7.8, 9.4])\ny = np.array([7.8, 19.1, 17.6, 33.9, 45.4])\n\n# Standard uncertainties in y\nuy = np.array([0.91, 2.3, 3.3, 1.8, 4.1])\n\n# Create a linear model and specify a weighted fit\nmodel = LinearModel(weighted=True)\n\n# Use a default initial guess (do not specify params) and apply the fit\nresult = model.fit(x, y, uy=uy)\n\n# Evaluate the model using the \"result\" object to create a fit line\nx_fit = np.linspace(np.min(x), np.max(x), 1000)\ny_fit = model.evaluate(x_fit, result)\n\n# Evaluate the residuals\nresiduals = y - model.evaluate(x, result)\n\n# Prepare two plots (one for the data and fit, one for the residuals)\nax1 = plt.subplot(211)\nax2 = plt.subplot(212)\n\n# Plot the data with the fit line\nax1.errorbar(x, y, yerr=uy, c='blue', fmt='o', capsize=5.0)\nax1.plot(x_fit, y_fit, c='red')\nax1.set_title('Data and Fit')\n\n# Plot the residuals (and show the y=0 axis)\nax2.scatter(x, residuals, c='blue')\nax2.set_title('Residuals')\nax2.axhline(y=0, color='black', linewidth=0.5)\n\n# Display the plots (and add some more spacing between the plots)\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n</code></pre> <p> </p>"},{"location":"examples/weighted_and_correlated/","title":"2D, Weighted and Correlated","text":"<p>This example uses a Model with the equation specified as a string. The independent variable (stimulus) data is two-dimensional (i.e., contains \\(x_1\\) and \\(x_2\\) variables). There are uncertainties in both \\(x\\) and \\(y\\) variables and the \\(y-y\\) correlation coefficient is 0.5, the \\(x_1-x_1\\) correlation coefficient is 0.8 and the set_correlation method is called to set the correlation matrices in the model.</p> <p>Prepare the model</p> <pre><code>import numpy as np\nfrom msl.nlf import Model\n\n# Sample data\nx = np.array([[1, 2, 3, 4], [0.1, 0.2, 0.3, 0.4]])\ny = np.array([1.1, 1.9, 3.2, 3.7])\n\n# Standard uncertainties in x and y\nux = np.array([[0.01, 0.02, 0.03, 0.04], [0.002, 0.004, 0.006, 0.008]])\nuy = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Initial guess\nguess = np.array([0, 0.9, 0])\n\n# Specify the equation as a string\nmodel = Model(\"a1+a2*(x1+exp(a3*x1))+x2\")\n\n# Set the options for a weighted and correlated fit\nmodel.options(weighted=True, correlated=True)\n\n# Define the correlation coefficient matrices, the value is set in the\n# off-diagonal matrix elements of the correlation matrix\nmodel.set_correlation(\"y\", \"y\", 0.5)\nmodel.set_correlation(\"x1\", \"x1\", 0.8)\n</code></pre> <p>To see a summary of the data that would be sent to the fit function in the shared library, call the fit method with <code>debug=True</code> and print the returned object (an instance of Input is returned)</p> <pre><code>model_input = model.fit(x, y, params=guess, uy=uy, ux=ux, debug=True)\nprint(model_input)\n</code></pre> <p>The summary that is printed is</p> <pre><code>Input(\n  absolute_residuals=True\n  correlated=True\n  correlations=    \n    Correlations(\n      data=[    \n        Correlation(\n          coefficients=[[1.  0.8 0.8 0.8]\n                        [0.8 1.  0.8 0.8]\n                        [0.8 0.8 1.  0.8]\n                        [0.8 0.8 0.8 1. ]]\n          path='.../CorrCoeffs X1-X1.txt'\n        ),\n        Correlation(\n          coefficients=[[1.  0.5 0.5 0.5]\n                        [0.5 1.  0.5 0.5]\n                        [0.5 0.5 1.  0.5]\n                        [0.5 0.5 0.5 1. ]]\n          path='.../CorrCoeffs Y-Y.txt'\n        )]\n      is_correlated=[[ True False False]\n                     [False  True False]\n                     [False False False]]\n    )\n  delta=0.1\n  equation='a1+a2*(x1+exp(a3*x1))+x2'\n  fit_method=&lt;FitMethod.LM: 'Levenberg-Marquardt'&gt;\n  max_iterations=999\n  params=    \n    InputParameters(\n      InputParameter(name='a1', value=0.0, constant=False, label=None),\n      InputParameter(name='a2', value=0.9, constant=False, label=None),\n      InputParameter(name='a3', value=0.0, constant=False, label=None)\n    )\n  residual_type=&lt;ResidualType.DY_X: 'dy v x'&gt;\n  second_derivs_B=True\n  second_derivs_H=True\n  tolerance=1e-20\n  ux=[[0.01  0.02  0.03  0.04 ]\n      [0.002 0.004 0.006 0.008]]\n  uy=[0.5 0.5 0.5 0.5]\n  uy_weights_only=False\n  weighted=True\n  x=[[1.  2.  3.  4. ]\n     [0.1 0.2 0.3 0.4]]\n  y=[1.1 1.9 3.2 3.7]\n)\n</code></pre> <p>To see a summary of the fit result, call the fit method with <code>debug=False</code> (which is also the default value) and print the returned object (an instance of Result is returned)</p> <pre><code>result = model.fit(x, y, params=guess, uy=uy, ux=ux, debug=False)\nprint(result)\n</code></pre> <p>The summary that is printed is</p> <pre><code>Result(\n  chisq=0.8548756002056555\n  correlation=[[ 1.         -0.81341696  0.33998683]\n               [-0.81341696  1.         -0.41807236]\n               [ 0.33998683 -0.41807236  1.        ]]\n  covariance=[[ 4.62857806e-01 -8.76652826e-02  2.75368388e-05]\n              [-8.76652826e-02  2.50946556e-02 -7.88442937e-06]\n              [ 2.75368388e-05 -7.88442937e-06  1.41728236e-08]]\n  dof=inf\n  eof=0.3271085789917953\n  iterations=33\n  num_calls=3\n  params=    \n    ResultParameters(\n      ResultParameter(name='a1', value=-0.6101880747640295, uncert=0.6803365385456949, label=None),\n      ResultParameter(name='a2', value=0.8100288869777271, uncert=0.15841292742566457, label=None),\n      ResultParameter(name='a3', value=4.585005881877272e-05, uncert=0.00011904966869050236, label=None)\n    )\n)\n</code></pre>"}]}